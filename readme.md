# Evaluating Fast VM Technics for Fuzzing.

## Instruction Set

There are five different types of instructions supported by the virtual machine.

| Instruction                      | Behavior                                                                                     |
|----------------------------------|----------------------------------------------------------------------------------------------|
| Terminals                        | Output strings to the buffer(Generated by grammar)                                                                |
| Non-terminals                    | Store the context into the calling stack; randomly choose a sub-program(sub-node in the grammar), and switch to it.(Generated by grammar) |
| Production Rules (expression)    | Store the context and push it into the calling stack; Switch to the program this production rule represents.(Generated by grammar) |
| RET                              | Pop the calling stack, re-store the program and IP                                           |
| HALT                             | Halt the virtual machine immediately                                                         |


## Threading Models 

### Indirect Threading Model

In the direct threading model, each operation code directly points to its corresponding execution code. This means that when an opcode is executed, it jumps directly to the code that implements that operation. In this program, variable IP (Instrcution pointer) indicates the offset of instruction table, then the virtual machine fetches the real address of instruction by adding the base address and offset so that execute it.

The example of instruction Table:
``` Forth
' RET instructions 0 cells + ! 
' HALT instructions 1 cells + ! 
' func_5527066576 instructions 2 cells + ! 
' func_5527066704 instructions 3 cells + ! 
' func_5527066128 instructions 4 cells + ! 
' func_5527066400 instructions 5 cells + ! 
' func_5527066256 instructions 6 cells + ! 
' func_5527066192 instructions 7 cells + ! 
' func_5527067568 instructions 8 cells + ! 
' func_5527066896 instructions 9 cells + ! 
' func_5527067760 instructions 10 cells + ! 
' func_5527067984 instructions 11 cells + ! 
' func_5527068112 instructions 12 cells + ! 
' func_5527068304 instructions 13 cells + ! 
' func_5527068432 instructions 14 cells + ! 
' func_5527068560 instructions 15 cells + ! 
' func_5527068688 instructions 16 cells + ! 
' func_5527068240 instructions 17 cells + ! 
' func_5527069088 instructions 18 cells + ! 
' func_5527067264 instructions 19 cells + ! 
' func_5527067824 instructions 20 cells + ! 
' func_5527069408 instructions 21 cells + ! 
' func_5527066960 instructions 22 cells + ! 
' func_5527069536 instructions 23 cells + ! 
' func_5527069664 instructions 24 cells + ! 
' func_5527069824 instructions 25 cells + ! 
' func_5527070112 instructions 26 cells + ! 
' func_5527070240 instructions 27 cells + ! 
' func_5527070368 instructions 28 cells + ! 
' func_5527070496 instructions 29 cells + ! 
```

Example of terminal instrution
``` Forth
: func_5536499168 ( -- )
    99 extend-char
    ip @ 1 cells + ip ! \ increment the instruction pointer
    ; 
```

Example of non-terminal instrution
``` Forth
create func_5536498544_op0 2 cells allot
3 func_5536498544_op0 0 cells + !
0 func_5536498544_op0 1 cells + !

: func_5536498544 ( -- )
    getdepth  maxdepth @ > if
        97 extend-char
        98 extend-char
        99 extend-char
         ip @ 1 cells + ip ! \ increment the instruction pointer
    else
        ip @ 
        rsp @ ! \ push the return address to the return stack 
        rsp @ 1 cells + rsp !  \ increment the return stack pointer 
        1 random
        case
            0 of
                func_5536498544_op0 ip ! endof
        endcase
    endif ; 
```

Example of production rule
``` Forth
: func_4947206080 ( -- )
    getdepth  maxdepth @ > if
        97 extend-char 
        98 extend-char 
        99 extend-char 
    ip @ 1 cells + ip ! \ increment the instruction pointer
    else
    ip @ 
    rsp @ ! \ push the return address to the return stack 
    rsp @ 1 cells + rsp !  \ increment the return stack pointer 
    exp_4947206080 ip !
    endif ; 
```

Main loop
```Forth
: mainloop
    1 running !
    0 buffer-pos !
    begin
        running @
    while
        instructions ip @ @ cells + @ execute
    repeat
;
```
The instruction pointer(IP) always indicate to the next instruction to be executed, to make sure the calling processing is Indirect Threading Model as it may be impacted by the runtime of Forth, all instructions are generated with Continuation-Passing Style(CPS) so that making sure that Tail Call Optimization(TCO) enables if supported, instruction switching are always be executed as the last statement.

**Risk:** This method may impacted by the word 'execute' which used to jump to a specific address, in some Foth systems 'Address execute' are also been taken as function calls that brings extra time consumption 

### Direct Threading Model

Addresses in the thread are the addresses of machine language. This form is simple, but may have overheads because the thread consists only of machine addresses, so all further parameters must be loaded indirectly from memory. In this project, variable IP(instruction pointer) indicates the address of instruction directly. 

Example of terminal instrution
``` Forth
: func_4947206464 ( -- )
    99 extend-char
    ip @ 1 cells + ip ! \ increment the instruction pointer
    ; 
```

Example of non-terminal instrution
``` Forth
: func_4947205872 ( -- )
    getdepth  maxdepth @ > if
        97 extend-char
        98 extend-char
        99 extend-char
         ip @ 1 cells + ip ! \ increment the instruction pointer
    else
        ip @ 
        rsp @ ! \ push the return address to the return stack 
        rsp @ 1 cells + rsp !  \ increment the return stack pointer 
        1 random
        case
            0 of
                func_4947205872_op0 ip ! endof
        endcase
    endif ; 
```

Example of production rule
``` Forth
: func_4947206080 ( -- )
    getdepth  maxdepth @ > if
        97 extend-char 
        98 extend-char 
        99 extend-char 
    ip @ 1 cells + ip ! \ increment the instruction pointer
    else
    ip @ 
    rsp @ ! \ push the return address to the return stack 
    rsp @ 1 cells + rsp !  \ increment the return stack pointer 
    exp_4947206080 ip !
    endif ; 
```

Main loop
```Forth
: mainloop
    1 running !
    0 buffer-pos !
    begin
        running @
    while
        ip @  @ execute
    repeat
;
```
The instruction pointer(IP) always indicate to the next instruction to be executed, to make sure the calling processing is Indirect Threading Model as it may be impacted by the runtime of Forth, all instructions are generated with Continuation-Passing Style(CPS) so that making sure that Tail Call Optimization(TCO) enables if supported, instruction switching are always be executed as the last statement.

**Risk:** This method may impacted by the word 'execute' which used to jump to a specific address, in some Foth systems 'Address execute' are also been taken as function calls that brings extra time consumption; Accessing variable IP ifself may also cost time.

### Subroutine Threading Model

So-called "subroutine-threaded code" (also "call-threaded code") consists of a series of machine-language "call" instructions (or addresses of functions to "call", as opposed to direct threading's use of "jump").

Example of terminal instrution
``` Forth
: func_4923088224 ( dp -- ) { dp }
    99 extend-char
    ; 
```

Example of non-terminal instrution
``` Forth
: func_4923087632 ( dp -- ) { dp }
    dp maxdepth @ > if
        97 extend-char
        98 extend-char
        99 extend-char
    else
        1 random
        case
            0 of
                dp 1 + func_4923087840 endof
        endcase
    endif ; 

```

Example of production rule
``` Forth
: func_4923087840 ( dp -- ) { dp }
    dp maxdepth @ > if
        97 extend-char 
        98 extend-char 
        99 extend-char 
    else
    dp 1 + func_4923087968
    dp 1 + func_4923088096
    dp 1 + func_4923088224
    endif ; 
```

**Risk:** Please note that the 'defer' keyword is used in this project (used to reserve a keyword in advance, to be implemented later). This keyword may be implemented and optimized differently on various Forth platforms, which can lead to additional overhead when using it.

How to use
```
$ clang++ -std=c++20 -stdlib=libc++ [IDT_generator.cpp | DT_generator.cpp | subroutine_generator.cpp ] -o generator
./generator -path <grammar.json> -depth <depth of recursion> -o <output forth file> [--show(enable enable benchmark)]
```
C++ is used to compile grammar rules into virtual machine, please make sure your C++ toolchain support C++20 or above.